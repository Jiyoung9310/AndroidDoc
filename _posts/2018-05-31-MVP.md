---
layout: post
title:  "Android에서의 MVP : 어떻게 프레젠테이션 레이아웃을 구성할지"
date:   2018-05-31
description: MVP 개념에 대해서 알아본다
---
<p class="intro"><span class="dropcap">안</span>드로이드 아키텍처</p>

# Android에서의 MVP : 프레젠테이션 레이아웃을 구성 방법(번역)

글쓴이 : Antonio Leiva
[이 블로그 글을 번역하였습니다.](https://antonioleiva.com/mvp-android/)


MVP패턴(Model View Presenter)은 잘 알려진 MVC(Model View Controller)에서 파생되었으며, 안드로이드 응용 프로그램 개발에 중요한 역할을 한다. 점점 더 많은 사람들이 그것에 대해 이야기하지만 신뢰할수 있는 구체적인 자료는 거의 없다. 그래서 나는 이 블로그를 통해 토론을 장려하고 우리의 모든 지식을 최대한 활용하여 프로젝트에 적용할 수 있도록 하고자한다.

## MVP란?
MVP패턴은 표현 레이어를 로직으로부터 분리시킨다. 그래서 모든 인터페이스 동작은 어떻게 화면에 표현될지로부터 분리된다. 이상적으로 MVP 패턴은 동일한 로직이 완전히 다른 상호 교환 가능한 뷰를 가질 수 있다.

먼저 분명히 해야할 것은 MVP는 아키텍쳐 패턴이 아니며, 프레젠테이션 레이어라는 것이다. 어찌됐든 당신의 아키텍처를 위해서 사용하지 않는 것보단 사용하는 것이 낫다.

## 왜 MVP를 사용하는가?
안드로이드에서는 액티비티가 인터페이스와 데이터 접근 매커니즘과 밀접하게 관련이 있기 때문에 문제가 발생한다. 뷰의 일부인 adapter와 cursor가 혼합된 CursorAdapter와 같은 극단적인 예를 찾아볼 수 있는데, 커서는 데이터 접근 계층으로 이격되어야한다.

애플리케이션이 쉽게 확장되고 유지될 수 있도록 하기 위해서 분리된 레이어를 잘 정의할 필요가 있다. 내일 당장 동일한 데이터 검색을 데이터베이스에서 하는 대신 웹 서비스에서 해야된다면? 우리는 모든 뷰를 고쳐야할 것이다.

MVP는 데이터 코드로부터 뷰를 독립적이게 만들어준다. 우리는 애플리케이션을 적어도 세가지 레이어로 나누어서 독립적으로 테스트 할 수 있다. MVP를 사용하면 instrumentation 테스트를 사용하지 않고도 액티비티로부터 대부분의 로직을 가져와서 테스트를 할 수 있다.

## MVP 구현 방법
음, 이것이 바로 모든 것이 시작된 원인이지. 아주 다양한 MVP 변형이 있고 모든 사람들이 자신이 편리하다고 생각하는 방향대로 패턴을 정의할 수 있다. 패턴 변형은 기본적으로 presenter가 어떤 역할을 담당하게 했는지에 따라 달라진다.

progress bar를 enable/disable할지를 뷰에서 설정해야 할까 presenter에서 설정해야 할까? 그리고 Action Bar에 표시될 액션은 누가 정의해야 할까? 어려운 결정이 시작된 것이다. 필자가 주로 사용하는 방법을 제시하겠지만, 나는 이 글이 MVP를 적용하는 방법에 대한 지침을 토론하는 장이 되길 바란다. 왜냐하면 그것을 구현하는 표준 방법이 없기 때문이다.

## Presenter
presenter는 뷰와 모델의 중간자 역할을 한다. 모델에서 데이터를 찾아 형식화 된 데이터를 뷰로 리턴한다. 하지만 MVC와는 다르게, 뷰와 상호작용할 때 어떤 일이 발생할지를 결정한다.

## View
뷰는 보통 액티비티에 의해 구현되는데(앱의 구조에 따라 Fragment에 의해 구현될 수도 있다) presenter에 대한 reference가 포함된다. presenter는 Dagger와 같은 종속성 인젝터를 통해 제공되는 것이 이상적인데, 이것을 사용하지않을 경우 presenter객체를 생성해야 한다. 뷰가 할 일은 버튼 클릭과 같은 예처럼 UI 액션이 발생될 때 마다 presenter에 있는 메소드를 호출하는 것 뿐이다.

## Model
좋은 계층구조를 가진 애플리케이션에서의 모델은 도메인 계층 또는 비즈니스 로직의 게이트웨이가 된다. 만약 [Uncle Bob의 clean architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)를 사용한다면, 모델은 아마 use case를 구현하는 상호 작용자 역할을 할 것이다. 하지만 이것은 앞으로의 글에서 논의하고자 하는 또 다른 주제이다. 지금은 뷰에 표시하고싶은 데이터를 제공하는 역할로 아는 것으로 충분하다.

## 예시
설명하면 길니까, [MVP 예시를 Github](https://github.com/antoniolg/androidmvp)에 만들어놓았다. 데이터 유효성 검사와 홈으로 접근 허용. 모델에서 검색한 item 리스트가 있는 홈 화면으로의 접근
이 게시글은 코드가 아주 심플하기 때문에 설명은 하지 않을 것이다. 하지만 이해하기 어렵다면 다른 글에서 자세하게 설명하겠다.

코틀린으로 작성한 예시를 보고싶다면 [Kotlin for Android Developers book](https://antonioleiva.com/kotlin-android-developers-book/)에 있는 [sample App](https://github.com/antoniolg/Kotlin-for-Android-Developers)을 보거나 [온라인 코스](https://antonioleiva.com/online-course/)를 확인해보시라.

## 결론
안드로이드에서 로직과 화면을 분리하는 것은 쉽지 않다. 하지만 Model-View-Presenter 패턴은 액티비티가 수백 수천 라인으로 구성된 강한 결합의 클래스로 변질되는 상황을 막기 수월하게 만든다. 대규모 애플리케이션에서는 코드를 잘 구성하는 것이 필수이다. 그렇지 못한다면 유지보수와 확장이 어렵게 될 것이다.
