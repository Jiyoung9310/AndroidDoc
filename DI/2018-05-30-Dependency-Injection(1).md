---
layout: post
title:  "Android에서의 Dependency injection : Dagger(1)"
date:   2018-05-30
description: DI가 무엇인지 알아본다.
---
<p class="intro"><span class="dropcap">안</span>드로이드 아키텍처</p>

# Android에서의 Dependency injection : Dagger(1)(번역)

글쓴이 : Antonio Leiva
[이 블로그 글을 번역하였습니다.](https://antonioleiva.com/dependency-injection-android-dagger-part-1/)


이번 새로운 포스팅 시리즈는 의존성 주입이 무엇인지, 그것의 사용 목적은 무엇인지, 어떻게 사용하는지에 대해서 안드로이드 프로젝트의 Dagger를 통해 설명할 것이다. Dagger는 안드로이드를 염두하여 설계된 최고의 구현체로 알려져있다.

이 글은 이전 포스트인 [MVP for Android](https://antonioleiva.com/mvp-android/)의 후속이라고 볼 수 있다. 여러분들 중 일부가 같은 프로젝트에서 구현된 MVP를 보는 것에 꽤 관심있어하는 것을 알고 있기 때문이다. 그리고 나는 그것들이 함께 잘 동작한다고 생각한다.

이 첫번째 파트는 기초를 잡는 짧은 이론이 될 것이다. DI가 무엇이고 왜 존재하는지 이해하는 것이 중요한데, 그걸 이해하지 못한다면 노력만큼 이익이 따르지 않는다고 생각하게 될 것이다.

## Denpendency(의존성)이란?
만약 우리가 의존성 주입을 원한다면, 우리는 먼저 의존성이 뭔지 알아야한다. 한마디로 의존성은 두 모듈(객체 지향에서는 두 클래스) 사이의 결합인데, 일반적으로 하나의 모듈이 다른 것을 사용하면서 생기는 결합이다.

## 의존성은 왜 위험한가?
상위에서 하위 레벨의 의존은 매우 위험하다. 왜냐하면 두 모듈을 한 방향으로 결합하기 때문에, 한 모듈을 다른 모듈로 변경할 경우에 반드시 결합된 모듈의 코드를 수정해야한다. 그것은 testable한 앱을 생성하기에 매우 좋지않다. 왜냐하면 단위 테스트는 모듈을 테스트할 때 app에 있는 다른 나머지 모듈들에 대해서 독립적이어야 하기 때문이다. 이를 위해서 의존성을 mock(가짜)로 대체하는 것이 필요하다. 다음과 같은 코드를 생각해보자.
~~~
public class Module1 {
	private Module2 module2;
    
    public Module1() {
    	module2 = new Module2();
    }
    
    public void doSomething(){
    	...
        module2.doSomethingElse();
        ...
    }
}
~~~
어떻게 'doSomethingElse'을 제외하고 'doSomething'만 테스트할 수 있을까? 만약 위와 같은 상황에서 테스트를 실패한다면, 어떤 메소드가 실패 원인일지 우리는 알 수 없다. 그리고 만약 'doSomethingElse'에서 데이터베이스에 무언가 저장하거나 API를 호출한다면 상황은 더 악화될 것이다.

모든 'new'는 매우 강한 의존성이므로 피해야되며, 그렇다고해서 모듈 사용을 줄이는 것은 해결책이 아니다. 단일 책임 원칙을 잊지마라.(?)(원본 : don’t forget single responsibility principle.)

## 어떻게 해결하나? Dependency inversion(의존성 전도)
만약 다른 모듈 내에 있는 모듈들을 추상화할 수 없다면, 우리는 그 모듈들을 다른 방법으로 제공해야 할 것이다. 어떤 방법으로? 바로 '생성자'를 통해서! 이것은 의존성 전도 원리(?)의 가장 기본이다. 추상 모듈에서만 구체적인 모듈 객체에 의존해서는 안된다.

예제 코드는 다음과 같다.
~~~
public class Module1{
	private Module2 module2;
    
    public Module1(Module2 module2) {
    	this.module2 = module2;
    }
    
    public void doSomething() {
    	...
        module2.doSomethingElse();
        ...
    }
}
~~~

## 그래서 의존성 주입(DI)이 무엇이냐?
넌 이미 알고있다! 다른 모듈에서 모듈을 생성하는 작업을 없애기 위해 생성자를 통해 의존성을 전달하는 것이다. 객체는 외부에서 인스턴스화되며, 현 객체가 만들어질 때 생성자 매개변수를 통해 전달된다.

하지만, 새로운 문제가 생긴다. 모듈 안에서 모듈 생성이 불가능하다면, 그 모듈이 인스턴스화될 곳이 필요하다. 게다가, 많은 의존성을 포함한 거대한 생성자가 있는 모듈을 만들어야된다면 코드는 매우 지저분해지고 가독성이 떨어지게 된다. 우리의 앱의 비중을 둘러싼 물체로(?뭔말이야?)(원본 : with objects travelling around the inmensity of our app.) 그걸 바로 의존성 주입이 해결한다.

## Dependency injector는 무엇이냐?
우리는 다른 나머지 모듈의 인스턴스 생성을 담당하고 의존성을 주입하는 모듈이 존재하는 것을 생각해볼 수 있다. 그게 의존성 주입 모듈의 가장 기본적인 의무이다. 모듈 생성은 앱의 한 지점에 위치해있으며, 모든 기능을 완벽하게 제어할 수 있다.

## 마지막으로...Dagger는 무엇인가?
Dagger는 low-end 장치용으로 설계된 의존성 인젝터이다. 대부분의 의존성 인젝터는 리플렉션에 의존하여(?) 의존성을 만들고 주입한다. 리플렉션은 근사하지만 시간이 많이 소요된다. 오래된 안드로이드 버전일수록 더 그렇다. 하지만 Dagger는 작업에 필요한 모든 클래스를 만드는 pre-compiler를 사용한다. 이럴 경우 리플렉션이 필요가 없다. Dagger는 다른 인젝터보다 강력하진 않지만 더 효율적이다.

## Dagger는 테스트만을 위한 것인지?
물론 그렇지 않다! 다른 앱에서 모듈을 재사용하거나, 같은 앱 내에서 모듈을 변경하는 경우에 더 쉽게 만들어줄 수 있다. 로컬 파일들의 디버그 데이터와 운영 API 서비스 데이터를 가져오는 앱이 있다고 예를 들어보자. 각 상황 별로 하나의 모듈 또는 다른 모듈을 주입함으로써 완벽하게 할 수 있다.

## 결론
필자도 이 포스팅 내용이 약간은 어렵다는 걸 알지만, 우리가 다음 내용을 다루기 위해선 용어를 바로 잡는 것이 매우 중요하다. 우리는 이미 의존성이 뭔지, 의존성 전도로 개선하는 것이 무엇인지, 의존성 인젝터를 활용해 구현하는 방법이 뭔지 알았다.
다음 내용에서는 우리는 손을 더럽힐 것이다(?!) 긴장하라구!
